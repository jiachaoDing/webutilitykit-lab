## 1) 组件交互时序图（文字版）

### 1.1 字典同步时序（每日）

参与者：`Cron(sync)` → `Worker(Hono)` → `WarframeMarket v2` → `D1`

1. `Cron(sync)` 触发（例如 UTC 03:00）
2. `Worker` 计算任务名 `sync_rivens`
3. `Worker → v2/versions` 获取 `collections.rivens`（base64 版本戳）
4. `Worker → D1(sync_state)` 读取本地 `rivens_version_b64`
5. 若版本未变化：

   * `Worker` 写 `job_run(status=success, detail={skipped:true})`
   * 结束
6. 若版本变化：

   * `Worker → v2/riven/weapons` 拉取武器字典
   * `Worker → D1(riven_weapon_dict)` 批量 upsert
   * （可选）`Worker → v2/riven/attributes` 拉取词条字典并 upsert
   * `Worker → D1(sync_state)` 更新 `rivens_version_b64`
   * `Worker` 写 `job_run(status=success, detail={updated:true, counts...})`
7. 结束

---

### 1.2 价格采样时序（每 5 分钟触发一个分片）

参与者：`Cron(sample shard k)` → `Worker(Hono)` → `D1` → `WarframeMarket v1` → `D1`

1. `Cron(sample)` 在分钟 `m ∈ {0,5,10,15,20,25,30,35,40,45,50,55}` 触发
2. `Worker` 计算 `current_shard = map_minute_to_shard(m)`（0..5）
3. `Worker` 计算 `window_ts = floor_to_30min(now_utc)`（例如 15:30:00Z）
4. **重入防护**：

   * `Worker → (KV or D1 lock)` 尝试获取 `lock:sample:{window_ts}:{shard}`
   * 如果锁已存在：写 `job_run(status=success, detail={skipped:true, reason:"locked"})`，结束
5. `Worker → D1(tracked_weapon)` 查询 `enabled=1` 且 `hash(slug)%6 == current_shard` 的武器列表（按 priority desc）
6. `Worker` 初始化全局节流器（令牌桶 rate=2 rps）、并发上限 `MAX_CONCURRENCY`
7. 对列表执行并发队列处理（每个武器一次）：

   1. `Worker → v1/auctions/search` 拉取拍卖 JSON（type=riven & sort_by=price_asc & weapon_url_name=slug）
   2. 解析 `payload.auctions`
   3. 过滤：`visible && !closed && owner.status=="ingame" && buyout_price!=null`
   4. 取 buyout 前 10（用于剔除异常与补位）
   5. 异常剔除 + Top5 加权 → 得 `bottom_price`、`sample_count`、`min_price`、`p5_price`
   6. `Worker → D1(riven_bottom_tick)` UPSERT 写入：

      * `ts = window_ts`
      * `captured_at = now_utc`（可选）
      * 主键 `(ts, platform, weapon_slug)`
8. `Worker` 汇总 success/no_data/error 统计
9. `Worker → D1(job_run)` 写入本次分片任务执行记录
10. 释放锁（或等 TTL 到期）
11. 结束

---

### 1.3 前端查询趋势时序

参与者：`Client` → `Worker(Hono API)` → `KV(optional)` → `D1`

1. `Client → GET /api/riven/bottom-trend?weapon=...&range=...`
2. `Worker` 校验参数（weapon 是否存在于字典）
3. `Worker → KV` 查缓存（key=weapon+range+platform）
4. 若命中：

   * 返回缓存
5. 若未命中：

   * `Worker → D1(riven_bottom_tick)` 按范围查询并排序
   * `Worker` 组装 meta + data 返回
   * `Worker → KV` 写缓存（TTL 5~10 分钟）
6. 返回给 Client

---

## 2) 模块职责边界（清晰分层，Cursor 好生成）

> 核心原则：把“外部 API 适配”“业务算法”“存储访问”“路由层”分开，避免耦合。

### 2.1 路由层（Hono）

* 职责：参数校验、HTTP 状态码、响应格式、鉴权（如未来需要）
* 不做：外部 API 调用细节、不写复杂 SQL、不过多业务逻辑

### 2.2 Service 层（业务用例）

* `SyncService`：版本比较 + 同步 weapons/attributes
* `SamplingService`：分片采样调度（取 tracked 列表、并发队列、节流器）
* `TrendService`：查询趋势/当前底价 + 缓存策略

### 2.3 Client 层（外部 API 适配）

* `WfmV2Client`：versions / riven/weapons / riven/attributes
* `WfmV1Client`：auctions search
* 统一处理：超时、重试、响应结构容错、错误标准化

### 2.4 Domain 层（纯逻辑）

* `BottomPriceCalculator`

  * 输入：拍卖列表（已解析成内部 Auction DTO）
  * 输出：bottom_price、sample_count、min_price、p5_price、status
  * 负责：过滤 ingame/closed/visible、异常剔除、加权计算
* `Sharding`

  * `hashSlug(slug) -> shard`
  * `minuteToShard(minute) -> shard`
  * `windowTs(now) -> ts`

### 2.5 Repository 层（D1 访问）

* `WeaponRepo`：riven_weapon_dict 查询/ upsert
* `TrackedRepo`：tracked_weapon 查询
* `TickRepo`：写 tick、查趋势、查最新
* `SyncStateRepo`：读写版本戳
* `JobRunRepo`：记录任务执行结果
* 注意：SQL 统一集中在 repo，避免散落

### 2.6 Infra 层

* `RateLimiter`：令牌桶/节流器（2 rps）
* `Lock`：KV 锁或 D1 锁（可切换实现）
* `Cache`：KV 缓存（可切换实现）
* `Logger`：统一日志结构（job_id、shard、window_ts）

---

## 3) 目录结构建议（适配 Workers + Hono + TypeScript）

```
src/
  index.ts                  # Worker 入口：Hono app + routes + cron handlers
  routes/
    weapons.ts              # /api/weapons
    riven.ts                # /api/riven/bottom-now, /api/riven/bottom-trend
    health.ts               # /api/health
  jobs/
    sampleShard.ts          # 分片采样入口（由 cron 调用）
    syncRivens.ts           # 字典同步入口（由 cron 调用）
  services/
    SamplingService.ts
    SyncService.ts
    TrendService.ts
  clients/
    WfmV1Client.ts
    WfmV2Client.ts
  domain/
    BottomPriceCalculator.ts
    Sharding.ts
    types.ts                # Auction DTO、Weapon DTO、Tick DTO
  repos/
    D1.ts                   # D1 helper（prepare/bind）
    WeaponRepo.ts
    TrackedRepo.ts
    TickRepo.ts
    SyncStateRepo.ts
    JobRunRepo.ts
  infra/
    RateLimiter.ts
    Lock.ts                 # KVLock / D1Lock 两套实现
    Cache.ts                # KVCache
    Time.ts                 # window_ts 对齐
  config/
    env.ts                  # 读取 env vars、默认值、校验
migrations/
  0001_init.sql
  0002_add_job_run.sql
```

---

## 4) Cron 触发与分片映射（文档化规则）

### 4.1 Cron 配置（建议一个 cron + 内部映射 或多 cron）

你选择了“多 Cron 分片”，推荐写法（概念）：

* 00/30 → shard 0
* 05/35 → shard 1
* 10/40 → shard 2
* 15/45 → shard 3
* 20/50 → shard 4
* 25/55 → shard 5

在实现上：

* **允许**用一个每 5 分钟的 Cron，然后 `minuteToShard` 做映射
* **或**配置 6 个 Cron 分别触发不同 shard（更直观）

> Cursor 实现时可任选其一，但必须保证 shard 覆盖完整窗口。

---

## 5) 采样“窗口对齐”规范（落库一致性）

* `window_ts = floor(now_utc, 30 minutes)`
* tick 主键使用 `window_ts`
* `captured_at = now_utc`（可选）
* 如同一窗口重复写入：UPSERT 覆盖（以 captured_at 最新为准）

